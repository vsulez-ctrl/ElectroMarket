const jwt = require("jsonwebtoken");
const ENV = require("../config/ENV");
const Usuario = require("../Modelo/Entidades/Usuario");
const SeguridadUsuario = require("../Modelo/Entidades/SeguridadUsuario");
const EmailService = require("./Email.service");
const pool = require("../config/bd");
const CryptoJS = require("crypto-js");

class AuthService {
    static getEncryptionKey() {
        return 'electromarket-frontend-2024-secure-key';
    }

    static decryptPassword(encryptedPassword) {
        try {
            console.log("üîì Intentando desencriptar:", encryptedPassword);
            
            if (!encryptedPassword.includes('U2FsdGVkX1')) {
                console.log("üìù Password no encriptado, usando tal cual");
                return encryptedPassword;
            }
            
            const bytes = CryptoJS.AES.decrypt(encryptedPassword, this.getEncryptionKey());
            const password = bytes.toString(CryptoJS.enc.Utf8);
            
            if (password) {
                console.log("‚úÖ Password desencriptado correctamente");
                return password;
            } else {
                console.log("‚ö†Ô∏è No se pudo desencriptar, usando original");
                return encryptedPassword;
            }
        } catch (error) {
            console.log("‚ùå Error en desencriptaci√≥n, usando original:", error.message);
            return encryptedPassword;
        }
    }

    async registrar(usuarioData) {
        const { nombre, email, password, direccion, telefono } = usuarioData;

        console.log("üìù Datos recibidos en registrar:", { nombre, email, direccion, telefono });

        let decryptedPassword = AuthService.decryptPassword(password);
        console.log("üîë Password despu√©s de desencriptar:", decryptedPassword);

        if (!nombre || !email || !decryptedPassword) {
            throw new Error("Nombre, email y contrase√±a son obligatorios");
        }

        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(email)) {
            throw new Error("Formato de email inv√°lido");
        }

        const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*]).{8,}$/;
        if (!passwordRegex.test(decryptedPassword)) {
            throw new Error("La contrase√±a debe tener m√≠nimo 8 caracteres, incluyendo al menos 1 may√∫scula, 1 min√∫scula, 1 n√∫mero y 1 s√≠mbolo (!@#$%^&*).");
        }

        const usuarioExistente = await Usuario.buscarPorEmail(email);
        if (usuarioExistente) {
            throw new Error("El email ya est√° registrado");
        }

        const tipoUsuario = 'cliente';
        const usuario = await Usuario.crear({
            email,
            password: decryptedPassword,
            nombre,
            tipoUsuario
        });

        await pool.query(
            `INSERT INTO clientes (usuario_id, nombre_cliente, correo_cliente, direccion, telefono) 
             VALUES ($1, $2, $3, $4, $5)`,
            [usuario.id, nombre, email, direccion || '', telefono || '']
        );
        
        return {
            id: usuario.id,
            email: usuario.email,
            nombre: usuario.nombre,
            direccion: direccion || '',
            telefono: telefono || '',
            tipo: 'cliente'
        };
    }

    async login(email, password) {
        try {
            console.log("üîê INICIANDO LOGIN ===================");
            console.log("üìß Email recibido:", email);
            console.log("üîë Password recibido (crudo):", password);
            
            let decryptedPassword = AuthService.decryptPassword(password);
            console.log("üîì Password despu√©s de desencriptar:", decryptedPassword);

            const usuario = await Usuario.buscarPorEmail(email);
            
            if (!usuario) {
                console.log("‚ùå Usuario no encontrado");
                throw new Error("Credenciales inv√°lidas");
            }

            const seguridad = await SeguridadUsuario.obtenerPorUsuarioId(usuario.id);
            if (seguridad.estaBloqueado()) {
                throw new Error("Cuenta bloqueada temporalmente. Intente en 30 minutos.");
            }

            console.log("üîç Verificando contrase√±a...");
            const esValido = await usuario.verificarPassword(decryptedPassword);

            if (!esValido) {
                const intentos = await seguridad.registrarIntentoFallido();
                const restantes = seguridad.obtenerIntentosRestantes();
                
                if (restantes > 0) {
                    throw new Error(`Credenciales inv√°lidas. Le quedan ${restantes} intentos.`);
                } else {
                    throw new Error("Cuenta bloqueada por m√∫ltiples intentos fallidos.");
                }
            }

            await seguridad.reiniciarIntentos();

            // ‚úÖ FORZAR VERIFICACI√ìN - ELIMINAR CUALQUIER VERIFICACI√ìN PREVIA
            console.log("üîÑ FORZANDO verificaci√≥n de c√≥digo...");
            
            // Resetear cualquier verificaci√≥n previa
            await pool.query(
                'UPDATE usuarios SET email_verificado = false WHERE id = $1',
                [usuario.id]
            );

            const codigoVerificacion = EmailService.generarCodigoVerificacion();
            const expiracion = new Date();
            expiracion.setMinutes(expiracion.getMinutes() + 10);

            await pool.query(
                'UPDATE usuarios SET codigo_verificacion = $1, codigo_expiracion = $2 WHERE id = $3',
                [codigoVerificacion, expiracion, usuario.id]
            );

            try {
                const emailService = new EmailService();
                await emailService.enviarCodigoVerificacion(
                    usuario.email, 
                    usuario.nombre, 
                    codigoVerificacion
                );

                console.log('üìß C√≥digo de verificaci√≥n enviado a:', usuario.email);
                
                // ‚úÖ RETORNAR SOLO LOS DATOS DE VERIFICACI√ìN, SIN TOKEN
                return { 
                    requiereVerificacion: true,
                    mensaje: "Se ha enviado un c√≥digo de verificaci√≥n a tu correo electr√≥nico",
                    usuarioId: usuario.id,
                    email: usuario.email
                };
            } catch (emailError) {
                console.error('‚ùå Error enviando correo:', emailError);
                throw new Error("Error al enviar el c√≥digo de verificaci√≥n. Intenta nuevamente.");
            }

        } catch (error) {
            console.error("üí• ERROR EN LOGIN:", error.message);
            throw new Error(error.message);
        }
    }

    async verificarCodigo(usuarioId, codigo) {
        try {
            console.log("üîç Verificando c√≥digo para usuario:", usuarioId);
            console.log("üî¢ C√≥digo recibido:", codigo);

            const result = await pool.query(
                `SELECT codigo_verificacion, codigo_expiracion 
                 FROM usuarios 
                 WHERE id = $1`,
                [usuarioId]
            );

            if (result.rows.length === 0) {
                throw new Error("Usuario no encontrado");
            }

            const usuario = result.rows[0];
            console.log("üì¶ C√≥digo en BD:", usuario.codigo_verificacion);
            console.log("‚è∞ Expiraci√≥n:", usuario.codigo_expiracion);

            if (!usuario.codigo_verificacion) {
                throw new Error("No hay c√≥digo de verificaci√≥n pendiente");
            }

            if (new Date() > new Date(usuario.codigo_expiracion)) {
                throw new Error("El c√≥digo de verificaci√≥n ha expirado");
            }

            if (usuario.codigo_verificacion !== codigo) {
                throw new Error("C√≥digo de verificaci√≥n incorrecto");
            }

            await pool.query(
                `UPDATE usuarios 
                 SET email_verificado = true, 
                     codigo_verificacion = NULL,
                     codigo_expiracion = NULL 
                 WHERE id = $1`,
                [usuarioId]
            );

            console.log('‚úÖ Email verificado para usuario:', usuarioId);

            // ‚úÖ Generar token despu√©s de verificaci√≥n exitosa
            const usuarioData = await pool.query(
                'SELECT * FROM usuarios WHERE id = $1',
                [usuarioId]
            );
            
            const usuarioCompleto = usuarioData.rows[0];
            let usuarioInfo = await this.obtenerInfoUsuario(new Usuario(
                usuarioCompleto.id,
                usuarioCompleto.correo,
                usuarioCompleto.contrase√±a,
                usuarioCompleto.nombre,
                usuarioCompleto.tipo_usuario
            ));

            const token = jwt.sign(
                { 
                    id: usuarioCompleto.id, 
                    email: usuarioCompleto.correo, 
                    rol: usuarioCompleto.tipo_usuario,
                    nombre: usuarioCompleto.nombre
                }, 
                ENV.JWT_SECRET, 
                { expiresIn: "2h" }
            );

            return {
            message: "Email verificado exitosamente",
            token: token,
            usuario: usuarioInfo
            };

        } catch (error) {
            console.error("‚ùå Error verificando c√≥digo:", error);
            throw new Error(error.message);
        }
    }

    async reenviarCodigoVerificacion(usuarioId) {
        try {
            console.log("üîÑ Reenviando c√≥digo para usuario:", usuarioId);
            
            const usuarioResult = await pool.query(
                'SELECT id, correo, nombre FROM usuarios WHERE id = $1',
                [usuarioId]
            );

            if (usuarioResult.rows.length === 0) {
                throw new Error("Usuario no encontrado");
            }

            const usuario = usuarioResult.rows[0];

            const codigoVerificacion = EmailService.generarCodigoVerificacion();
            const expiracion = new Date();
            expiracion.setMinutes(expiracion.getMinutes() + 10);

            await pool.query(
                'UPDATE usuarios SET codigo_verificacion = $1, codigo_expiracion = $2 WHERE id = $3',
                [codigoVerificacion, expiracion, usuarioId]
            );

            const emailService = new EmailService();
            await emailService.enviarCodigoVerificacion(
                usuario.correo, 
                usuario.nombre, 
                codigoVerificacion
            );

            console.log('üìß Nuevo c√≥digo enviado a:', usuario.correo);

            return { 
                exito: true, 
                mensaje: "Se ha enviado un nuevo c√≥digo de verificaci√≥n a tu correo" 
            };

        } catch (error) {
            console.error('‚ùå Error reenviando c√≥digo:', error);
            throw new Error(error.message);
        }
    }

    async obtenerInfoUsuario(usuario) {
        let usuarioInfo;
        if (usuario.tipoUsuario === 'administrador') {
            const adminData = await pool.query('SELECT * FROM administradores WHERE usuario_id = $1', [usuario.id]);
            const admin = adminData.rows[0];
            usuarioInfo = {
                id: usuario.id,
                email: usuario.email,
                nombre: usuario.nombre,
                direccion: admin?.direccion || '',
                telefono: admin?.telefono || '',
                tipo: 'admin'
            };
        } else {
            const clienteData = await pool.query('SELECT * FROM clientes WHERE usuario_id = $1', [usuario.id]);
            const cliente = clienteData.rows[0];
            usuarioInfo = {
                id: usuario.id,
                email: usuario.email,
                nombre: usuario.nombre,
                direccion: cliente?.direccion || '',
                telefono: cliente?.telefono || '',
                tipo: 'cliente'
            };
        }
        return usuarioInfo;
    }

    verificarToken(token) {
        try {
            return jwt.verify(token, ENV.JWT_SECRET);
        } catch (error) {
            throw new Error("Token inv√°lido o expirado");
        }
    }

    async obtenerTodosLosClientes() {
        try {
            const result = await pool.query(`
                SELECT u.*, c.direccion, c.telefono 
                FROM usuarios u 
                JOIN clientes c ON u.id = c.usuario_id
            `);
            return result.rows.map(row => ({
                id: row.id,
                email: row.correo,
                nombre: row.nombre,
                direccion: row.direccion,
                telefono: row.telefono,
                tipo: 'cliente'
            }));
        } catch (error) {
            throw new Error('Error al obtener clientes: ' + error.message);
        }
    }

    async obtenerTodosLosAdministradores() {
        try {
            const result = await pool.query(`
                SELECT u.* 
                FROM usuarios u 
                JOIN administradores a ON u.id = a.usuario_id
            `);
            return result.rows.map(row => ({
                id: row.id,
                email: row.correo,
                nombre: row.nombre,
                tipo: 'admin'
            }));
        } catch (error) {
            throw new Error('Error al obtener administradores: ' + error.message);
        }
    }
}

module.exports = AuthService;